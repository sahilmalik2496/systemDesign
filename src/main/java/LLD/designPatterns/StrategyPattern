The Strategy Design Pattern is a behavioral design pattern that enables selecting an algorithm's behavior at runtime. It defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern is useful when you want to avoid multiple if-else or switch statements for choosing behavior.

üîß When to Use Strategy Pattern
You have multiple algorithms for a specific task.

The algorithm needs to be selected at runtime.

You want to reduce complex conditional logic.

You want to adhere to the Open/Closed Principle (open for extension, closed for modification).

üß± Key Components
Strategy (Interface) ‚Äì Common interface for all supported algorithms.

Concrete Strategies ‚Äì Implementations of the Strategy interface.

Context ‚Äì Uses a Strategy object and is configured with a Concrete Strategy.

üì¶ Java Example: Payment Strategy
Let‚Äôs consider a payment system that allows paying by Credit Card or UPI.

1. Strategy Interface
java
Copy
Edit
public interface PaymentStrategy {
    void pay(int amount);
}
2. Concrete Strategies
java
Copy
Edit
public class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;

    public CreditCardPayment(String cardNumber) {
        this.cardNumber = cardNumber;
    }

    public void pay(int amount) {
        System.out.println("Paid ‚Çπ" + amount + " using Credit Card: " + cardNumber);
    }
}

public class UpiPayment implements PaymentStrategy {
    private String upiId;

    public UpiPayment(String upiId) {
        this.upiId = upiId;
    }

    public void pay(int amount) {
        System.out.println("Paid ‚Çπ" + amount + " using UPI: " + upiId);
    }
}
3. Context
java
Copy
Edit
public class PaymentContext {
    private PaymentStrategy paymentStrategy;

    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void payAmount(int amount) {
        if (paymentStrategy == null) {
            throw new IllegalStateException("Payment Strategy not set");
        }
        paymentStrategy.pay(amount);
    }
}
4. Client Code
java
Copy
Edit
public class StrategyPatternExample {
    public static void main(String[] args) {
        PaymentContext context = new PaymentContext();

        context.setPaymentStrategy(new CreditCardPayment("1234-5678-9876-5432"));
        context.payAmount(500);

        context.setPaymentStrategy(new UpiPayment("user@upi"));
        context.payAmount(300);
    }
}
‚úÖ Output
sql
Copy
Edit
Paid ‚Çπ500 using Credit Card: 1234-5678-9876-5432
Paid ‚Çπ300 using UPI: user@upi
‚úÖ Advantages
Cleaner code with better separation of concerns.

Open for extension: New algorithms can be added without changing existing code.

Removes tight coupling between context and algorithm.

‚ùå Disadvantages
Increases the number of classes.

Client must be aware of different strategies to choose appropriately.

üîÅ Real-world Use Cases
Sorting with different comparators.

Payment gateways.

Compression algorithms (ZIP, RAR, etc.).

Authentication strategies (OAuth, SAML, JWT, etc.).

Let me know if you want this example in another language (e.g., Python, C#, etc.) or a UML diagram version.